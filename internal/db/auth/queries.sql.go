// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.28.0
// source: queries.sql

package authsqlc

import (
	"context"
	"database/sql"
	"time"

	"github.com/lib/pq"
	"github.com/sqlc-dev/pqtype"
)

const addClientRole = `-- name: AddClientRole :exec
UPDATE clients
SET role = array_append(role, $2::text)
WHERE client_token = $1 AND NOT ($2 = ANY(role))
`

type AddClientRoleParams struct {
	ClientToken string
	Roletoadd   string
}

func (q *Queries) AddClientRole(ctx context.Context, arg AddClientRoleParams) error {
	_, err := q.exec(ctx, q.addClientRoleStmt, addClientRole, arg.ClientToken, arg.Roletoadd)
	return err
}

const createClient = `-- name: CreateClient :exec
INSERT INTO clients (client_name, client_token, role)
VALUES ($1, $2, $3)
`

type CreateClientParams struct {
	ClientName  string
	ClientToken string
	Role        []string
}

func (q *Queries) CreateClient(ctx context.Context, arg CreateClientParams) error {
	_, err := q.exec(ctx, q.createClientStmt, createClient, arg.ClientName, arg.ClientToken, pq.Array(arg.Role))
	return err
}

const createRefreshToken = `-- name: CreateRefreshToken :exec
INSERT INTO refresh_tokens (client_token, token, expires_at)
VALUES ($1, $2, $3)
`

type CreateRefreshTokenParams struct {
	ClientToken string
	Token       string
	ExpiresAt   time.Time
}

func (q *Queries) CreateRefreshToken(ctx context.Context, arg CreateRefreshTokenParams) error {
	_, err := q.exec(ctx, q.createRefreshTokenStmt, createRefreshToken, arg.ClientToken, arg.Token, arg.ExpiresAt)
	return err
}

const createRevokedRefreshToken = `-- name: CreateRevokedRefreshToken :exec
INSERT INTO revoked_refresh_tokens (token)
VALUES ($1)
`

func (q *Queries) CreateRevokedRefreshToken(ctx context.Context, token string) error {
	_, err := q.exec(ctx, q.createRevokedRefreshTokenStmt, createRevokedRefreshToken, token)
	return err
}

const createRevokedToken = `-- name: CreateRevokedToken :exec
INSERT INTO revoked_tokens (client_token)
VALUES ($1)
`

func (q *Queries) CreateRevokedToken(ctx context.Context, clientToken string) error {
	_, err := q.exec(ctx, q.createRevokedTokenStmt, createRevokedToken, clientToken)
	return err
}

const deleteAllRefreshTokensForClient = `-- name: DeleteAllRefreshTokensForClient :exec
DELETE FROM refresh_tokens WHERE client_token = $1
`

func (q *Queries) DeleteAllRefreshTokensForClient(ctx context.Context, clientToken string) error {
	_, err := q.exec(ctx, q.deleteAllRefreshTokensForClientStmt, deleteAllRefreshTokensForClient, clientToken)
	return err
}

const deleteClient = `-- name: DeleteClient :exec
DELETE FROM clients WHERE client_token = $1
`

func (q *Queries) DeleteClient(ctx context.Context, clientToken string) error {
	_, err := q.exec(ctx, q.deleteClientStmt, deleteClient, clientToken)
	return err
}

const deleteExpiredRefreshTokens = `-- name: DeleteExpiredRefreshTokens :exec
DELETE FROM refresh_tokens WHERE expires_at < now()
`

func (q *Queries) DeleteExpiredRefreshTokens(ctx context.Context) error {
	_, err := q.exec(ctx, q.deleteExpiredRefreshTokensStmt, deleteExpiredRefreshTokens)
	return err
}

const deleteRefreshToken = `-- name: DeleteRefreshToken :exec
DELETE FROM refresh_tokens WHERE token = $1
`

func (q *Queries) DeleteRefreshToken(ctx context.Context, token string) error {
	_, err := q.exec(ctx, q.deleteRefreshTokenStmt, deleteRefreshToken, token)
	return err
}

const deleteRefreshTokenByToken = `-- name: DeleteRefreshTokenByToken :exec
DELETE FROM refresh_tokens
WHERE token = $1
`

func (q *Queries) DeleteRefreshTokenByToken(ctx context.Context, token string) error {
	_, err := q.exec(ctx, q.deleteRefreshTokenByTokenStmt, deleteRefreshTokenByToken, token)
	return err
}

const deleteRevokedRefreshToken = `-- name: DeleteRevokedRefreshToken :exec
DELETE FROM revoked_refresh_tokens WHERE token = $1
`

func (q *Queries) DeleteRevokedRefreshToken(ctx context.Context, token string) error {
	_, err := q.exec(ctx, q.deleteRevokedRefreshTokenStmt, deleteRevokedRefreshToken, token)
	return err
}

const deleteRevokedToken = `-- name: DeleteRevokedToken :exec
DELETE FROM revoked_tokens WHERE client_token = $1
`

func (q *Queries) DeleteRevokedToken(ctx context.Context, clientToken string) error {
	_, err := q.exec(ctx, q.deleteRevokedTokenStmt, deleteRevokedToken, clientToken)
	return err
}

const getClientByName = `-- name: GetClientByName :one
SELECT id, client_name, client_token, role, created_at
FROM clients
WHERE client_name = $1
`

func (q *Queries) GetClientByName(ctx context.Context, clientName string) (Client, error) {
	row := q.queryRow(ctx, q.getClientByNameStmt, getClientByName, clientName)
	var i Client
	err := row.Scan(
		&i.ID,
		&i.ClientName,
		&i.ClientToken,
		pq.Array(&i.Role),
		&i.CreatedAt,
	)
	return i, err
}

const getClientByToken = `-- name: GetClientByToken :one
SELECT id, client_name, client_token, role, created_at
FROM clients
WHERE client_token = $1
`

func (q *Queries) GetClientByToken(ctx context.Context, clientToken string) (Client, error) {
	row := q.queryRow(ctx, q.getClientByTokenStmt, getClientByToken, clientToken)
	var i Client
	err := row.Scan(
		&i.ID,
		&i.ClientName,
		&i.ClientToken,
		pq.Array(&i.Role),
		&i.CreatedAt,
	)
	return i, err
}

const getClientRoles = `-- name: GetClientRoles :one
SELECT role
FROM clients
WHERE client_token = $1
`

func (q *Queries) GetClientRoles(ctx context.Context, clientToken string) ([]string, error) {
	row := q.queryRow(ctx, q.getClientRolesStmt, getClientRoles, clientToken)
	var role []string
	err := row.Scan(pq.Array(&role))
	return role, err
}

const getClientsByRole = `-- name: GetClientsByRole :many
SELECT id, client_name, client_token, role, created_at
FROM clients
WHERE $1 = ANY(role)
`

func (q *Queries) GetClientsByRole(ctx context.Context, role []string) ([]Client, error) {
	rows, err := q.query(ctx, q.getClientsByRoleStmt, getClientsByRole, pq.Array(role))
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Client
	for rows.Next() {
		var i Client
		if err := rows.Scan(
			&i.ID,
			&i.ClientName,
			&i.ClientToken,
			pq.Array(&i.Role),
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getLogsByAction = `-- name: GetLogsByAction :many
SELECT id, client_token, token_type, action, token, ip_address, user_agent, metadata, created_at
FROM token_logs
WHERE action = $1
ORDER BY created_at DESC
`

func (q *Queries) GetLogsByAction(ctx context.Context, action string) ([]TokenLog, error) {
	rows, err := q.query(ctx, q.getLogsByActionStmt, getLogsByAction, action)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []TokenLog
	for rows.Next() {
		var i TokenLog
		if err := rows.Scan(
			&i.ID,
			&i.ClientToken,
			&i.TokenType,
			&i.Action,
			&i.Token,
			&i.IpAddress,
			&i.UserAgent,
			&i.Metadata,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getLogsByClient = `-- name: GetLogsByClient :many
SELECT id, client_token, token_type, action, token, ip_address, user_agent, metadata, created_at
FROM token_logs
WHERE client_token = $1
ORDER BY created_at DESC
`

func (q *Queries) GetLogsByClient(ctx context.Context, clientToken string) ([]TokenLog, error) {
	rows, err := q.query(ctx, q.getLogsByClientStmt, getLogsByClient, clientToken)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []TokenLog
	for rows.Next() {
		var i TokenLog
		if err := rows.Scan(
			&i.ID,
			&i.ClientToken,
			&i.TokenType,
			&i.Action,
			&i.Token,
			&i.IpAddress,
			&i.UserAgent,
			&i.Metadata,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getLogsByTokenType = `-- name: GetLogsByTokenType :many
SELECT id, client_token, token_type, action, token, ip_address, user_agent, metadata, created_at
FROM token_logs
WHERE token_type = $1
ORDER BY created_at DESC
`

func (q *Queries) GetLogsByTokenType(ctx context.Context, tokenType string) ([]TokenLog, error) {
	rows, err := q.query(ctx, q.getLogsByTokenTypeStmt, getLogsByTokenType, tokenType)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []TokenLog
	for rows.Next() {
		var i TokenLog
		if err := rows.Scan(
			&i.ID,
			&i.ClientToken,
			&i.TokenType,
			&i.Action,
			&i.Token,
			&i.IpAddress,
			&i.UserAgent,
			&i.Metadata,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getRefreshToken = `-- name: GetRefreshToken :one
SELECT id, client_token, token, expires_at, created_at
FROM refresh_tokens
WHERE token = $1
`

func (q *Queries) GetRefreshToken(ctx context.Context, token string) (RefreshToken, error) {
	row := q.queryRow(ctx, q.getRefreshTokenStmt, getRefreshToken, token)
	var i RefreshToken
	err := row.Scan(
		&i.ID,
		&i.ClientToken,
		&i.Token,
		&i.ExpiresAt,
		&i.CreatedAt,
	)
	return i, err
}

const getRefreshTokenByClient = `-- name: GetRefreshTokenByClient :one
SELECT id, client_token, token, expires_at, created_at
FROM refresh_tokens
WHERE client_token = $1
ORDER BY created_at DESC
LIMIT 1
`

func (q *Queries) GetRefreshTokenByClient(ctx context.Context, clientToken string) (RefreshToken, error) {
	row := q.queryRow(ctx, q.getRefreshTokenByClientStmt, getRefreshTokenByClient, clientToken)
	var i RefreshToken
	err := row.Scan(
		&i.ID,
		&i.ClientToken,
		&i.Token,
		&i.ExpiresAt,
		&i.CreatedAt,
	)
	return i, err
}

const hasRole = `-- name: HasRole :one
SELECT EXISTS (
  SELECT 1 FROM clients
  WHERE client_token = $1
    AND $2 = ANY(role)
) AS has_role
`

type HasRoleParams struct {
	ClientToken string
	Role        []string
}

func (q *Queries) HasRole(ctx context.Context, arg HasRoleParams) (bool, error) {
	row := q.queryRow(ctx, q.hasRoleStmt, hasRole, arg.ClientToken, pq.Array(arg.Role))
	var has_role bool
	err := row.Scan(&has_role)
	return has_role, err
}

const insertNewRefreshToken = `-- name: InsertNewRefreshToken :exec
INSERT INTO refresh_tokens (client_token, token, expires_at)
VALUES ($1, $2, $3)
`

type InsertNewRefreshTokenParams struct {
	ClientToken string
	Token       string
	ExpiresAt   time.Time
}

func (q *Queries) InsertNewRefreshToken(ctx context.Context, arg InsertNewRefreshTokenParams) error {
	_, err := q.exec(ctx, q.insertNewRefreshTokenStmt, insertNewRefreshToken, arg.ClientToken, arg.Token, arg.ExpiresAt)
	return err
}

const insertRevokedRefreshToken = `-- name: InsertRevokedRefreshToken :exec
INSERT INTO revoked_refresh_tokens (token)
VALUES ($1)
`

func (q *Queries) InsertRevokedRefreshToken(ctx context.Context, token string) error {
	_, err := q.exec(ctx, q.insertRevokedRefreshTokenStmt, insertRevokedRefreshToken, token)
	return err
}

const insertTokenLog = `-- name: InsertTokenLog :exec
INSERT INTO token_logs (
    client_token,
    token_type,
    action,
    token,
    ip_address,
    user_agent,
    metadata
) VALUES ($1, $2, $3, $4, $5, $6, $7)
`

type InsertTokenLogParams struct {
	ClientToken string
	TokenType   string
	Action      string
	Token       sql.NullString
	IpAddress   sql.NullString
	UserAgent   sql.NullString
	Metadata    pqtype.NullRawMessage
}

func (q *Queries) InsertTokenLog(ctx context.Context, arg InsertTokenLogParams) error {
	_, err := q.exec(ctx, q.insertTokenLogStmt, insertTokenLog,
		arg.ClientToken,
		arg.TokenType,
		arg.Action,
		arg.Token,
		arg.IpAddress,
		arg.UserAgent,
		arg.Metadata,
	)
	return err
}

const isRefreshTokenExpired = `-- name: IsRefreshTokenExpired :one
SELECT expires_at < now() AS is_expired
FROM refresh_tokens
WHERE token = $1
`

func (q *Queries) IsRefreshTokenExpired(ctx context.Context, token string) (bool, error) {
	row := q.queryRow(ctx, q.isRefreshTokenExpiredStmt, isRefreshTokenExpired, token)
	var is_expired bool
	err := row.Scan(&is_expired)
	return is_expired, err
}

const isRevokedRefreshToken = `-- name: IsRevokedRefreshToken :one
SELECT EXISTS (
    SELECT 1 FROM revoked_refresh_tokens WHERE token = $1
) AS revoked
`

func (q *Queries) IsRevokedRefreshToken(ctx context.Context, token string) (bool, error) {
	row := q.queryRow(ctx, q.isRevokedRefreshTokenStmt, isRevokedRefreshToken, token)
	var revoked bool
	err := row.Scan(&revoked)
	return revoked, err
}

const isRevokedToken = `-- name: IsRevokedToken :one
SELECT EXISTS (
    SELECT 1 FROM revoked_tokens WHERE client_token = $1
) AS revoked
`

func (q *Queries) IsRevokedToken(ctx context.Context, clientToken string) (bool, error) {
	row := q.queryRow(ctx, q.isRevokedTokenStmt, isRevokedToken, clientToken)
	var revoked bool
	err := row.Scan(&revoked)
	return revoked, err
}

const listClients = `-- name: ListClients :many
SELECT id, client_name, client_token, role, created_at
FROM clients
ORDER BY created_at DESC
`

func (q *Queries) ListClients(ctx context.Context) ([]Client, error) {
	rows, err := q.query(ctx, q.listClientsStmt, listClients)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Client
	for rows.Next() {
		var i Client
		if err := rows.Scan(
			&i.ID,
			&i.ClientName,
			&i.ClientToken,
			pq.Array(&i.Role),
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const removeClientRole = `-- name: RemoveClientRole :exec
UPDATE clients
SET role = array_remove(role, $2::text)
WHERE client_token = $1
`

type RemoveClientRoleParams struct {
	ClientToken  string
	Roletoremove string
}

func (q *Queries) RemoveClientRole(ctx context.Context, arg RemoveClientRoleParams) error {
	_, err := q.exec(ctx, q.removeClientRoleStmt, removeClientRole, arg.ClientToken, arg.Roletoremove)
	return err
}

const updateClientRoles = `-- name: UpdateClientRoles :exec
UPDATE clients SET role = $2
WHERE client_token = $1
`

type UpdateClientRolesParams struct {
	ClientToken string
	Role        []string
}

func (q *Queries) UpdateClientRoles(ctx context.Context, arg UpdateClientRolesParams) error {
	_, err := q.exec(ctx, q.updateClientRolesStmt, updateClientRoles, arg.ClientToken, pq.Array(arg.Role))
	return err
}

const updateClientToken = `-- name: UpdateClientToken :exec
UPDATE clients SET client_token = $2
WHERE client_name = $1
`

type UpdateClientTokenParams struct {
	ClientName  string
	ClientToken string
}

func (q *Queries) UpdateClientToken(ctx context.Context, arg UpdateClientTokenParams) error {
	_, err := q.exec(ctx, q.updateClientTokenStmt, updateClientToken, arg.ClientName, arg.ClientToken)
	return err
}
