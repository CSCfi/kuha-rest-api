// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: queries.sql

package archsqlc

import (
	"context"
	"database/sql"
)

const getRaceReport = `-- name: GetRaceReport :one
SELECT race_report
FROM report
WHERE sportti_id = $1 AND session_id = $2
`

type GetRaceReportParams struct {
	SporttiID sql.NullString
	SessionID sql.NullInt32
}

func (q *Queries) GetRaceReport(ctx context.Context, arg GetRaceReportParams) (sql.NullString, error) {
	row := q.queryRow(ctx, q.getRaceReportStmt, getRaceReport, arg.SporttiID, arg.SessionID)
	var race_report sql.NullString
	err := row.Scan(&race_report)
	return race_report, err
}

const getRaceReportSessionIDsBySporttiID = `-- name: GetRaceReportSessionIDsBySporttiID :many
SELECT session_id
FROM report
WHERE sportti_id = $1
ORDER BY session_id DESC
`

func (q *Queries) GetRaceReportSessionIDsBySporttiID(ctx context.Context, sporttiID sql.NullString) ([]sql.NullInt32, error) {
	rows, err := q.query(ctx, q.getRaceReportSessionIDsBySporttiIDStmt, getRaceReportSessionIDsBySporttiID, sporttiID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []sql.NullInt32
	for rows.Next() {
		var session_id sql.NullInt32
		if err := rows.Scan(&session_id); err != nil {
			return nil, err
		}
		items = append(items, session_id)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getSporttiIDs = `-- name: GetSporttiIDs :many
SELECT sportti_id
FROM sportti_id_list
ORDER BY sportti_id
`

func (q *Queries) GetSporttiIDs(ctx context.Context) ([]string, error) {
	rows, err := q.query(ctx, q.getSporttiIDsStmt, getSporttiIDs)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []string
	for rows.Next() {
		var sportti_id string
		if err := rows.Scan(&sportti_id); err != nil {
			return nil, err
		}
		items = append(items, sportti_id)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const upsertAthlete = `-- name: UpsertAthlete :one
INSERT INTO athlete (
  national_id, first_name, last_name, initials, date_of_birth, height, weight
) VALUES ($1, $2, $3, $4, $5, $6, $7)
ON CONFLICT (national_id) DO UPDATE SET
  first_name    = COALESCE(EXCLUDED.first_name,    athlete.first_name),
  last_name     = COALESCE(EXCLUDED.last_name,     athlete.last_name),
  initials      = COALESCE(EXCLUDED.initials,      athlete.initials),
  date_of_birth = COALESCE(EXCLUDED.date_of_birth, athlete.date_of_birth),
  height        = COALESCE(EXCLUDED.height,        athlete.height),
  weight        = COALESCE(EXCLUDED.weight,        athlete.weight)
RETURNING national_id, first_name, last_name, initials, date_of_birth, height, weight
`

type UpsertAthleteParams struct {
	NationalID  string
	FirstName   sql.NullString
	LastName    sql.NullString
	Initials    sql.NullString
	DateOfBirth sql.NullTime
	Height      sql.NullString
	Weight      sql.NullString
}

func (q *Queries) UpsertAthlete(ctx context.Context, arg UpsertAthleteParams) (Athlete, error) {
	row := q.queryRow(ctx, q.upsertAthleteStmt, upsertAthlete,
		arg.NationalID,
		arg.FirstName,
		arg.LastName,
		arg.Initials,
		arg.DateOfBirth,
		arg.Height,
		arg.Weight,
	)
	var i Athlete
	err := row.Scan(
		&i.NationalID,
		&i.FirstName,
		&i.LastName,
		&i.Initials,
		&i.DateOfBirth,
		&i.Height,
		&i.Weight,
	)
	return i, err
}

const upsertMeasurement = `-- name: UpsertMeasurement :one
INSERT INTO measurement (
  measurement_group_id, measurement_id, national_id, discipline, session_name,
  place, race_id, start_time, stop_time, nb_segments, comment
) VALUES (
  $1, $2, $3, $4, $5,
  $6, $7, $8, $9, $10, $11
)
ON CONFLICT (measurement_group_id) DO UPDATE SET
  measurement_id = COALESCE(EXCLUDED.measurement_id, measurement.measurement_id),
  national_id    = COALESCE(EXCLUDED.national_id,    measurement.national_id),
  discipline     = COALESCE(EXCLUDED.discipline,     measurement.discipline),
  session_name   = COALESCE(EXCLUDED.session_name,   measurement.session_name),
  place          = COALESCE(EXCLUDED.place,          measurement.place),
  race_id        = COALESCE(EXCLUDED.race_id,        measurement.race_id),
  start_time     = COALESCE(EXCLUDED.start_time,     measurement.start_time),
  stop_time      = COALESCE(EXCLUDED.stop_time,      measurement.stop_time),
  nb_segments    = COALESCE(EXCLUDED.nb_segments,    measurement.nb_segments),
  comment        = COALESCE(EXCLUDED.comment,        measurement.comment)
RETURNING measurement_group_id, measurement_id, national_id, discipline, session_name,
          place, race_id, start_time, stop_time, nb_segments, comment
`

type UpsertMeasurementParams struct {
	MeasurementGroupID int32
	MeasurementID      sql.NullInt32
	NationalID         sql.NullString
	Discipline         sql.NullString
	SessionName        sql.NullString
	Place              sql.NullString
	RaceID             sql.NullInt32
	StartTime          sql.NullTime
	StopTime           sql.NullTime
	NbSegments         sql.NullInt32
	Comment            sql.NullString
}

func (q *Queries) UpsertMeasurement(ctx context.Context, arg UpsertMeasurementParams) (Measurement, error) {
	row := q.queryRow(ctx, q.upsertMeasurementStmt, upsertMeasurement,
		arg.MeasurementGroupID,
		arg.MeasurementID,
		arg.NationalID,
		arg.Discipline,
		arg.SessionName,
		arg.Place,
		arg.RaceID,
		arg.StartTime,
		arg.StopTime,
		arg.NbSegments,
		arg.Comment,
	)
	var i Measurement
	err := row.Scan(
		&i.MeasurementGroupID,
		&i.MeasurementID,
		&i.NationalID,
		&i.Discipline,
		&i.SessionName,
		&i.Place,
		&i.RaceID,
		&i.StartTime,
		&i.StopTime,
		&i.NbSegments,
		&i.Comment,
	)
	return i, err
}

const upsertRaceReport = `-- name: UpsertRaceReport :one
INSERT INTO report (sportti_id, session_id, race_report)
VALUES ($1, $2, $3)
ON CONFLICT (session_id) DO UPDATE SET
  sportti_id  = COALESCE(EXCLUDED.sportti_id,  report.sportti_id),
  race_report = COALESCE(EXCLUDED.race_report, report.race_report)
RETURNING report_id, sportti_id, session_id, race_report
`

type UpsertRaceReportParams struct {
	SporttiID  sql.NullString
	SessionID  sql.NullInt32
	RaceReport sql.NullString
}

func (q *Queries) UpsertRaceReport(ctx context.Context, arg UpsertRaceReportParams) (Report, error) {
	row := q.queryRow(ctx, q.upsertRaceReportStmt, upsertRaceReport, arg.SporttiID, arg.SessionID, arg.RaceReport)
	var i Report
	err := row.Scan(
		&i.ReportID,
		&i.SporttiID,
		&i.SessionID,
		&i.RaceReport,
	)
	return i, err
}
