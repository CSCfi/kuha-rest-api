// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: queries.sql

package archsqlc

import (
	"context"
	"database/sql"
)

const getRaceReport = `-- name: GetRaceReport :one
SELECT race_report
FROM report
WHERE sportti_id = $1 AND session_id = $2
`

type GetRaceReportParams struct {
	SporttiID sql.NullString
	SessionID sql.NullInt32
}

func (q *Queries) GetRaceReport(ctx context.Context, arg GetRaceReportParams) (sql.NullString, error) {
	row := q.queryRow(ctx, q.getRaceReportStmt, getRaceReport, arg.SporttiID, arg.SessionID)
	var race_report sql.NullString
	err := row.Scan(&race_report)
	return race_report, err
}

const getRaceReportSessionIDsBySporttiID = `-- name: GetRaceReportSessionIDsBySporttiID :many
SELECT session_id
FROM report
WHERE sportti_id = $1
ORDER BY session_id DESC
`

func (q *Queries) GetRaceReportSessionIDsBySporttiID(ctx context.Context, sporttiID sql.NullString) ([]sql.NullInt32, error) {
	rows, err := q.query(ctx, q.getRaceReportSessionIDsBySporttiIDStmt, getRaceReportSessionIDsBySporttiID, sporttiID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []sql.NullInt32
	for rows.Next() {
		var session_id sql.NullInt32
		if err := rows.Scan(&session_id); err != nil {
			return nil, err
		}
		items = append(items, session_id)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getSporttiIDs = `-- name: GetSporttiIDs :many
SELECT sportti_id
FROM sportti_id_list
ORDER BY sportti_id
`

func (q *Queries) GetSporttiIDs(ctx context.Context) ([]string, error) {
	rows, err := q.query(ctx, q.getSporttiIDsStmt, getSporttiIDs)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []string
	for rows.Next() {
		var sportti_id string
		if err := rows.Scan(&sportti_id); err != nil {
			return nil, err
		}
		items = append(items, sportti_id)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const upsertAthlete = `-- name: UpsertAthlete :exec
INSERT INTO athlete (
  national_id, first_name, last_name, initials, date_of_birth, height, weight
) VALUES ($1, $2, $3, $4, $5, $6, $7)
ON CONFLICT (national_id) DO UPDATE SET
  first_name    = EXCLUDED.first_name,
  last_name     = EXCLUDED.last_name,
  initials      = EXCLUDED.initials,
  date_of_birth = EXCLUDED.date_of_birth,
  height        = EXCLUDED.height,
  weight        = EXCLUDED.weight
`

type UpsertAthleteParams struct {
	NationalID  string
	FirstName   sql.NullString
	LastName    sql.NullString
	Initials    sql.NullString
	DateOfBirth sql.NullTime
	Height      sql.NullString
	Weight      sql.NullString
}

func (q *Queries) UpsertAthlete(ctx context.Context, arg UpsertAthleteParams) error {
	_, err := q.exec(ctx, q.upsertAthleteStmt, upsertAthlete,
		arg.NationalID,
		arg.FirstName,
		arg.LastName,
		arg.Initials,
		arg.DateOfBirth,
		arg.Height,
		arg.Weight,
	)
	return err
}

const upsertMeasurement = `-- name: UpsertMeasurement :exec
INSERT INTO measurement (
  measurement_group_id, measurement_id, national_id, discipline, session_name,
  place, race_id, start_time, stop_time, nb_segments, comment
) VALUES (
  $1, $2, $3, $4, $5,
  $6, $7, $8, $9, $10, $11
)
ON CONFLICT (measurement_group_id) DO UPDATE SET
  measurement_id = EXCLUDED.measurement_id,
  national_id    = EXCLUDED.national_id,
  discipline     = EXCLUDED.discipline,
  session_name   = EXCLUDED.session_name,
  place          = EXCLUDED.place,
  race_id        = EXCLUDED.race_id,
  start_time     = EXCLUDED.start_time,
  stop_time      = EXCLUDED.stop_time,
  nb_segments    = EXCLUDED.nb_segments,
  comment        = EXCLUDED.comment
`

type UpsertMeasurementParams struct {
	MeasurementGroupID int32
	MeasurementID      sql.NullInt32
	NationalID         sql.NullString
	Discipline         sql.NullString
	SessionName        sql.NullString
	Place              sql.NullString
	RaceID             sql.NullInt32
	StartTime          sql.NullTime
	StopTime           sql.NullTime
	NbSegments         sql.NullInt32
	Comment            sql.NullString
}

func (q *Queries) UpsertMeasurement(ctx context.Context, arg UpsertMeasurementParams) error {
	_, err := q.exec(ctx, q.upsertMeasurementStmt, upsertMeasurement,
		arg.MeasurementGroupID,
		arg.MeasurementID,
		arg.NationalID,
		arg.Discipline,
		arg.SessionName,
		arg.Place,
		arg.RaceID,
		arg.StartTime,
		arg.StopTime,
		arg.NbSegments,
		arg.Comment,
	)
	return err
}

const upsertRaceReport = `-- name: UpsertRaceReport :exec
INSERT INTO report (sportti_id, session_id, race_report)
VALUES ($1, $2, $3)
ON CONFLICT (session_id) DO UPDATE SET
  sportti_id  = EXCLUDED.sportti_id,
  race_report = EXCLUDED.race_report
`

type UpsertRaceReportParams struct {
	SporttiID  sql.NullString
	SessionID  sql.NullInt32
	RaceReport sql.NullString
}

func (q *Queries) UpsertRaceReport(ctx context.Context, arg UpsertRaceReportParams) error {
	_, err := q.exec(ctx, q.upsertRaceReportStmt, upsertRaceReport, arg.SporttiID, arg.SessionID, arg.RaceReport)
	return err
}
